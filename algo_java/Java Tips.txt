자바 팁

### 배열 -> 리스트 변환 

// 배열 생성
String[] array = {"apple", "banana", "cherry"};

// 배열을 리스트로 변환 (고정 크기 리스트)
List<String> list1 = Arrays.asList(array);
System.out.println(list1);  // 출력: [apple, banana, cherry]

// ArrayList로 변환하여 수정 가능한 리스트 만들기
List<String> list2 = new ArrayList<>(Arrays.asList(array));
list2.add("date");
System.out.println(list2);  // 출력: [apple, banana, cherry, date]

// list를 배열로 반환
list.stream().mapToInt(Integer::intValue).toArray();


int [] arr = {5,2,1,2,3,4,4};

// 중복제거 및 Integer 변환
Integer [] result = Arrays.stream(arr).boxed().distinct().toArray(Integer[]::new);
// 역순 정령
Arrays.sort(result,Comparator.reverseOrder());
// 다시 인트
int [] arr2 = Arrays.stream(result).mapToInt(Integer::intValue).toArray();
// 출력
System.out.println(Arrays.toString(arr2));


### 캐릭터, 스트링

s.charAt(i) - '0' -> 정수 나옴

char c = s.charAt(i);

Character.isDigit(c) -> 숫자인지 판단

String.join("",arr); -> arr에 있는거 다 더해서 string 반환 근데 내부적으론 StringBuilder 써서 속도도 빠름

### 정렬
// 배열 정렬 
Arrays.sort(arr);  // 기본적으로 오름차순 정렬
Arrays.sort(arr, Comparator.reverseOrder());  // 내림차순 정렬 <- 객체배열만 가능

// CollectionSort
Collections.sort(list);  // 오름차순 정렬
Collections.sort(list, Collections.reverseOrder());
// 단순히 역순으로 출력
Collections.reverse(list)

// 리스트
list.sort(null);  // 기본적으로 오름차순 정렬
list.sort(Comparator.reverseOrder());  // 내림차순 정렬


### 우선순위 큐
1. 최소 힙 PriorityQueue<Integer> minHeap = new PriorityQueue<>();

2. 최대 힙 PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());

add(E e), size(), isEmpty()	
peek()	최우선순위 요소를 반환(제거하지 않음).
poll()	최우선순위 요소를 반환하고 제거.


### 큐
Queue<Integer> queue = new LinkedList<>();
// FIFO (First In First Out) 방식으로 동작
// 주요 메서드: add(), poll(), peek(), isEmpty()

### 덱
Deque<Integer> deque = new ArrayDeque<>();
// 양방향으로 삽입/삭제 가능
// 주요 메서드: addFirst(), addLast(), removeFirst(), removeLast(), peekFirst(), peekLast()

### 스택
Stack<Integer> stack = new Stack<>();
// LIFO (Last In First Out) 방식으로 동작
// 주요 메서드: push(), pop(), peek(), isEmpty()


### 트리 셋
int[] arr = {5, 2, 1, 2, 3, 4, 4};

// TreeSet을 내림차순으로 정렬되도록 생성
TreeSet<Integer> ts = new TreeSet<>(Collections.reverseOrder());

// 배열의 요소를 TreeSet에 추가 (중복 제거 및 정렬)
for (int i : arr) {
    ts.add(i);
}

// TreeSet의 크기만큼 새로운 배열 생성
int[] arr2 = new int[ts.size()];

// TreeSet에서 요소를 꺼내어 새로운 배열에 저장
for (int i = 0; i < arr2.length; i++) {
    arr2[i] = ts.pollFirst();
}

// 결과 출력
System.out.println(Arrays.toString(arr2));